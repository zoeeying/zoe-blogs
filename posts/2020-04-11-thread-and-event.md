# 线程机制与事件机制

## 1 进程与线程

**进程**是指程序的一次执行，它占有一片独有的内存空间，可以通过 Windows 任务管理器查看进程。**多进程**是指一个应用程序可以同时启动多个运行实例。有的浏览器是**单进程**的，有的是**多进程**的。**进程**是 CPU **资源分配**的最小单位。

**线程**是进程内的一个独立执行单元，是程序执行的一个完整流程，是 CPU **调度**的最小单位。**多线程**是指在一个进程内，可以同时运行多个线程。**多线程**可以有效提升 CPU 的利用率，但是创建多线程和多线程间切换是需要开销的，还会导致死锁与状态同步问题。**单线程**的程序是顺序编程的，简单易懂，就是效率低。JavaScript 是**单线程**运行的，但是使用 H5 中的 Web Worker 可以实现**多线程**运行。浏览器是**多线程**的。

**下面是一些必须要了解的概念：**

应用程序代码必须运行在**某个进程**的**某个线程**上；一个进程中至少有一个运行的线程，即**主线程**，进程启动后会自动创建；一个进程中可以同时运行多个线程，可以说该程序是**多线程**运行的；一个进程中的数据可以供其中的多个线程直接共享；多个进程之间的数据是不能直接共享的，因为进程所占用的内存是相互独立、相互隔离的；**线程池**是保存多个线程对象的容器，可以实现线程对象的反复利用。

## 2 浏览器内核

**浏览器内核**是指支撑浏览器运行的最核心的程序。

浏览器内核是由很多模块组成的，可以分为**主线程模块**和**分线程模块**。

**主线程模块：**

- JS 引擎模块，负责 JS 程序的编译与运行
- HTML、CSS 文档解析模块，负责页面文本的解析
- DOM/CSS 模块：负责 DOM/CSS 在内存中的相关处理，转换成对象
- 布局和渲染模块：负责页面的布局和效果的绘制（参照内存中的对象）

**分线程模块：**

- 定时器模块，负责管理定时器
- DOM 事件响应模块，负责管理事件
- 网络请求模块，负责 ajax 请求

定时器并不能保证真正定时执行，一般会延迟一点点。定时器的回调函数是在主线程执行的，因为 JS 是单线程执行的。

## 3 JS 单线程

JS 是单线程执行的。为什么呢？与 JS 的用途有关，作为浏览器脚本语言，JS 的主要用途是与用户互动以及操作 DOM，这决定了它只能是单线程执行的，否则会带来很复杂的同步问题。

alert 会暂停当前主线程的执行（也会暂停计时），点击确定后，才会恢复程序执行。

定时器的的**回调函数（异步代码）**是在主线程执行的，只有在**运行栈中的代码**，即**同步代码**（设置定时器、绑定事件监听、发送 ajax 请求等），全部执行完毕后才可能执行，所以定时器会有误差。

## 4 事件循环模型

浏览器的事件循环（轮询）模型。

![事件驱动模型](../images/event-driven.png)

**上图中的一些概念介绍：**

stack，即执行栈（execution stack），所有代码都是在此空间中执行的；

callback queue，即**回调队列**，包括任务队列、消息队列、事件队列；

event loop，即事件轮询，从回调队列中循环取出（一个接一个）回调函数放入执行栈中来处理，即不断地从任务队列中取出任务执行的一个过程，它是一个程序结构，用于等待和分派消息和事件。

执行同步代码的时候，会将**事件回调函数**交给对应的模块（上图的 WebAPIs）来管理，当事件发生时，**管理模块**会将回调函数及其数据添加到**回调队列**中，当同步代码执行完后，才会去遍历读取并执行回调队列中的回调函数。

## 5 事件处理

客户端 JavaScript 程序采用了**异步事件驱动编程模型**。简而言之，事件就是 Web 浏览器通知应用程序发生了什么事情。

**事件类型（event type）：** 是一个用来说明发生什么类型事件的字符串，也叫**事件名称（event name）**。

**事件目标（event target）：** 是发生的事件或与之相关的对象，我们在讲事件时，必须同时指明类型和目标。

**事件处理程序（event handler）：** 也叫**事件监听程序（event listener）**，是处理或响应事件的函数。当事件目标上注册的事件处理程序被浏览器调用时，我们有时会说浏览器**触发（fire/trigger）**和**派发（dispatch）**了事件。

**事件对象（event object）：** 是与特定事件相关且包含有关事件详细信息的对象，事件对象作为参数传递给事件处理程序函数，所有事件对象都有用来指定事件类型的 type 属性和指定事件目标的 target 属性，每个**事件类型**都为其相关**事件对象**定义了一组属性。

**事件传播（event propagation）：** 是浏览器决定哪个对象触发其事件处理程序的过程。在 Document 或其它容器元素上注册单个事件处理程序比在每个独立的目标元素上都注册处理程序要更方便。事件处理程序能够通过**调用方法**或**设置事件对象属性**来阻止事件传播，这样它就能停止冒泡且将无法在容器元素上触发处理程序。 

**事件捕获（event capturing）：** 在容器元素上注册的特定处理程序有机会在事件传播到真实目标之前拦截（捕获）它。在处理鼠标拖放事件时，捕获或夺取鼠标事件的能力是必需的。

## 6 Web Worker

Web Worker 是 HTML5 提供的一个 JS 多线程解决方案。我们可以将一些大计算量的代码交由 Web Worker 运行，而不会冻结用户界面。但是分线程完全受主线程控制，且不得操作 DOM，所以这个新标准并没有改变 JS 单线程的本质。

Web Worker 处在一个自包含的执行环境（WorkerGlobalScope）中，无法访问 Window 对象和 Document 对象，和主线程之间的通信只能通过**异步消息的传递机制**来实现，这就意味着分线程是无法操作 DOM 和更新界面的。

![Web Worker](../images/web-worker.png)

**下面是一个小案例：**

1、创建在分线程执行的 JS 文件，比如 worker.js

```javascript
function fibonacci(n) {
  return n <= 2 ? 1 : fibonacci(n - 1) + fibonacci(n - 2)
}

// 不能用函数声明的方式
const onmessage = function (event) {
  // event.data是主线程发送过来的数据
  const number = event.data
  // postMessage方法将数据发送给主线程
  postMessage(fibonacci(number))
}
```

2、在主线程的 JS 中发消息并设置回调

```javascript
// 实例化Worker对象，传递想在分线程执行的脚本的scriptURL
const worker = new Worker('worker.js')
// 向分线程发送数据
worker.postMessage(12)
// 绑定接收消息的监听，event.data是分线程发送过来的数据
worker.onmessage = function (event) {
  console.log(event.data)
}
```
