# 线程机制与事件机制

## 1 进程与线程

**进程**是指程序的一次执行，它占有一片独有的内存空间，可以通过 Windows 任务管理器查看进程。**多进程**是指一个应用程序可以同时启动多个运行实例。有的浏览器是**单进程**的，有的是**多进程**的。**进程**是 CPU **资源分配**的最小单位。

**线程**是进程内的一个独立执行单元，是程序执行的一个完整流程，是 CPU **调度**的最小单位。**多线程**是指在一个进程内，可以同时运行多个线程。**多线程**可以有效提升 CPU 的利用率，但是创建多线程和多线程间切换是需要开销的，还会导致死锁与状态同步问题。**单线程**的程序是顺序编程的，简单易懂，就是效率低。JavaScript 是**单线程**运行的，但是使用 H5 中的 Web Workers 可以实现**多线程**运行。浏览器是**多线程**的。

**下面是一些必须要了解的概念：**

应用程序代码必须运行在**某个进程**的**某个线程**上；一个进程中至少有一个运行的线程，即**主线程**，进程启动后会自动创建；一个进程中可以同时运行多个线程，可以说该程序是**多线程**运行的；一个进程中的数据可以供其中的多个线程直接共享；多个进程之间的数据是不能直接共享的，因为进程所占用的内存是相互独立、相互隔离的；**线程池**是保存多个线程对象的容器，可以实现线程对象的反复利用。

## 2 浏览器内核

**浏览器内核**是指支撑浏览器运行的最核心的程序。

浏览器内核是由很多模块组成的，可以分为**主线程模块**和**分线程模块**。

**主线程模块：**

* JS 引擎模块，负责 JS 程序的编译与运行
* HTML、CSS 文档解析模块，负责页面文本的解析
* DOM/CSS 模块：负责 DOM/CSS 在内存中的相关处理，转换成对象
* 布局和渲染模块：负责页面的布局和效果的绘制（参照内存中的对象）

**分线程模块：**

* 定时器模块，负责管理定时器
* DOM 事件响应模块，负责管理事件
* 网络请求模块，负责 ajax 请求

定时器并不能保证真正定时执行，一般会延迟一点点。定时器的回调函数是在主线程执行的，因为 JS 是单线程执行的。

## 3 JS 单线程

JS 是单线程执行的。为什么呢？与 JS 的用途有关，作为浏览器脚本语言，JS 的主要用途是与用户互动以及操作 DOM，这决定了它只能是单线程执行的，否则会带来很复杂的同步问题。

alert 会暂停当前主线程的执行（也会暂停计时），点击确定后，才会恢复程序执行。

定时器的的**回调函数（异步代码）**是在主线程执行的，只有在**运行栈中的代码**，即**同步代码**（设置定时器、绑定事件监听、发送 ajax 请求等），全部执行完毕后才可能执行。

## 4 事件循环模型

浏览器的事件循环（轮询）模型。

![事件驱动模型](https://wx2.sinaimg.cn/mw690/600a9336gy1gd8m9u97dpj20i40g1q8g.jpg)

**上图中的一些概念介绍：**

stack，即执行栈（execution stack），都有代码都是在此空间中执行的；

callback queue，即**回调队列**，包括任务队列、消息队列、事件队列；

event loop，即事件轮询，从回调队列中循环取出（一个接一个）回调函数放入执行栈中来处理，即不断地从任务队列中取出任务执行的一个过程，它是一个程序结构，用于等待和分派消息和事件。

执行同步代码的时候，会将**事件回调函数**交给对应的模块（上图的 WebAPIs）来管理，当事件发生时，**管理模块**会将回调函数及其数据添加到**回调队列**中，当同步代码执行完后，才会去遍历读取并执行回调队列中的回调函数。

## 5 事件处理

客户端 JavaScript 程序采用了异步事件驱动编程模型。

## 6 Web Worker

Web Worker 是 HTML5 提供的一个 JS 多线程解决方案。我们可以将一些大计算量的代码交由 Web Worker 运行，而不会冻结用户界面。但是分线程完全受主线程控制，且不得操作 DOM，所以这个新标准并没有改变 JS 单线程的本质。

Web Worker 处在一个自包含的执行环境（WorkerGlobalScope）中，无法访问 Window 对象和 Document 对象，和主线程之间的通信只能通过异步消息的传递机制来实现，这就意味着分线程是无法操作 DOM 和更新界面的。

![Web Worker](https://wx3.sinaimg.cn/mw690/600a9336gy1gd8m9xvg7kj20oy0a9my0.jpg)

**下面是一个小案例的步骤：**

**步骤一：** 创建在分线程执行的 JS 文件，比如 worker.js

```javascript
function fibonacci(n) {
  return n <= 2 ? 1 : fibonacci(n - 1) + fibonacci(n - 2)
}

// 不能用函数声明的方式
const onmessage = function(event) {
  // event.data是主线程发送过来的数据
  const number = event.data
  // postMessage方法将数据发送给主线程
  postMessage(fibonacci(number))
}
```

**步骤二：** 在主线程的 JS 中发消息并设置回调

```javascript
// 实例化Worker对象，传递想在分线程执行的脚本的scriptURL
const worker = new Worker('worker.js')
// 向分线程发送数据
worker.postMessage(12)
// 绑定接收消息的监听，event.data是分线程发送过来的数据
worker.onmessage = function(event) {
  console.log(event.data)
}
```







