# 2020 年前端面试题

##### Q1：是否使用过 Redux？Redux 解决了什么问题？是如何解决的？

Redux 是为了解决 React 组件间通讯和组件间状态共享的问题，主要包括三个部分：store、action、reducer。



##### Q2：是否使用过 React Hooks？主要用于解决什么问题？

React Hooks 解决了 HOC 和 Render Props 的嵌套问题，更加简洁；React Hooks 可以更方便地把 UI 和状态分离，做到更彻底的解耦；Hooks 中可以引用另外的 Hooks 形成新的 Hooks，组合变化万千；React Hooks 为函数组件而生，函数式编程风格看起来更清爽，更容易发现没有使用的状态和函数，代码量更少，解决了类组件中 this 指向容易错误的问题，解决了类组件中的逻辑分散在不同生命周期中，使得代码难以理解和维护的问题，解决了高阶组件容易使代码量剧增，代码维护成本很高的问题；React Hooks 使得我们复用状态逻辑，拆分组件更容易。



##### Q3：Vue 兄弟组件通讯有哪些方式？

aaa



##### Q4：常见的网络安全攻击有哪些，如何预防？

SSR



##### Q5：复杂动画场景中，为什么要提醒它们创建新图层？

aaa



##### Q6：在 HTTPS 协议打开的 H5 页面内，有某些 JS 或 CSS 资源会被 block，这是什么原因？图片资源会吗？

aaa



##### Q7：JS 异步优化历史、原理是什么？

aaa



##### Q8：Cookie 和 Session 的区别？

由于 HTTP 协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是 Session。典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。

思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。

Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。

所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。



##### Q9：进程间如何通讯？

管道通信；消息队列通信；信号量通信；信号通信；共享内存通信；套接字通信



##### Q10：自己在技术上擅长哪一方面？

aaa



##### Q11：Vue 如何实现数据双向绑定？如何实现响应式数据？

Vue 数据双向绑定是通过**数据劫持**结合**发布者-订阅者模式**的方式来实现的。

通过 `Object.defineProperty()` 来劫持各个属性的 setter/getter，在 data 变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 `Object.defineProperty()` 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

Vue 的数据双向绑定将 MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 的数据变化，并在数据变化的时候发布通知，通过 Compile 来解析编译模板指令（`{{}}`），达到初始化视图的目的，并且还需要绑定更新函数，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，接收 Observer 发来的通知并执行 Compile 中相应的更新函数，达到数据变化 => 视图更新；视图交互变化（比如 input）=> 数据 model 变更的双向绑定效果。

```html
<body>
    <div id="app">
    <input type="text" id="txt">
    <p id="show"></p>
</div>
</body>
<script type="text/javascript">
    var obj = {}
    Object.defineProperty(obj, 'txt', {
        get: function () {
            return obj
        },
        set: function (newValue) {
            document.getElementById('txt').value = newValue
            document.getElementById('show').innerHTML = newValue
        }
    })
    document.addEventListener('keyup', function (e) {
        obj.txt = e.target.value
    })
</script>
```



##### Q12：为什么 Vue 组件中的 data 是一个函数？

每个 .vue 文件都是一个组件（组件是一个可复用的 Vue 实例），这就意味着如果 data 是一个普通的对象，那么所有复用这个实例的组件将共享引用同一个数据对象，这会造成数据污染，如果将 data 定义成一个函数，在实例化组件的时候，每个实例对象的 data 都是经过一次函数执行得到的全新的副本数据对象。

当一个**组件**被定义，`data` 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 `data` 仍然是一个纯粹的对象，则所有的实例将**共享引用**同一个数据对象！通过提供 `data` 函数，每次创建一个新实例后，我们能够调用 `data` 函数，从而返回初始数据的一个全新副本数据对象。



##### Q13：为什么使用 Flutter？跟 RN 和 Weex 比起来有什么优势？

Flutter 是一个跨平台 UI 开发框架，和以前的跨平台框架不同的是，它的**性能更好**，更接近原生并且跨平台体验更优秀，因为**它的跨平台实现机制更像是游戏引擎**。

Flutter 相较于 Weex 和 RN，性能强大、动画流畅；可以获得非常稳定的 UI 表达效果；避免了 RN 通过桥接器与Javascript 通讯导致效率低下的问题，所以在性能方面比 RN 更高一筹。



##### Q14：如何基于 Axios 封装请求？如果基于 Dio 封装请求？

aaa



##### Q15：HTTP 协议和 HTTPS 协议？

超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于 TCP/IP 协议传输数据，互联网上应用最为广泛的一种网络协议，所有的 WWW 文件都必须遵守这个标准。设计 HTTP 的初衷是为了提供一种发布和接收 HTML 页面的方法。HTTP 是一个基于 TCP/IP 通信协议来传递数据的协议，传输的数据类型为 HTML 文件、图片文件、查询结果等。

HTTPS 基于 HTTP 协议，通过 SSL 或 TLS 提供加密处理数据、验证对方身份以及数据完整性保护，一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。



##### Q16：token 过期怎么处理？

aaa



##### Q17：怎么理解 MVVM？

Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表视图，在 Vue.js 中代表 UI 组件，负责将数据模型转化成 UI 展示出来；View 和 Model 之间没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，因此 View 的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上，View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。



##### Q18：computed 和 watch 的区别和使用场景？

计算属性将被混入到 Vue 实例中。



##### Q19：hash 和 history？

hash 值变化不会导致浏览器向服务器发出请求；hash 虽然出现 url 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面；对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。



##### Q20：Vue 与 React 的区别？

都基于组件化的思想，组件之间可以嵌套；都基于 Virtual DOM 模型；都有官方提供的脚手架工具用来快速搭建应用。

React 使用 JSX，基于函数式编程的思想，使得开发人员可以充分利用 JavaScript 的编程能力；单向数据流，推崇结合 immutable 来实现数据不可变；手动性能优化；

Vue 使用 HTML 模板创建视图，且是国人开发的，文档是中文的，对于初次使用框架的人比较友好；双向数据绑定；对于将框架集成到现有项目中比较友好；响应式思想，监听属性变化，更新虚拟 DOM，更新视图；自动性能优化。



##### Q21：了解 keep-alive 吗？

**keep-alive** 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染，

在切换组件的时候，我们可能需要保存一些组件的状态，防止重复渲染，就可以使用 keep-alive 包裹需要保存状态的组件。 



##### Q22：Vue 中 key 的作用？React 中 key 的作用？

React 中 key 用来唯一标识同父同层级的兄弟元素，React 采用的 diff 算法是对新旧虚拟 DOM 树同层级的元素挨个进行比较，当 React 做 diff 时，只要子元素有 key 属性，便会去原虚拟 DOM 树中相应位置寻找是否有同 key 元素，比较它们是否完全相同，若相同则复用该元素，否则就进行更新。

Vue 中 key 的作用可以分为两种情况来考虑：

第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。

第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用**就地复用**的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，以便 Vue 跟踪元素的身份，从而高效的实现复用，这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。



##### Q23：$route 和 $router 的区别？

$route 是**路由信息对象**，包括 path、params、hash、query、fullPath、matched、name 等路由信息参数；

$router 是**路由实例对象**，包括了路由的跳转方法、钩子函数等。



##### Q24：ES6 Proxy？

Proxy 可以理解成在目标对象前架设一个**拦截层**，外界对该对象的访问都必须先通过这层拦截，因此提供了一种机制可以对外界的访问进行过滤和改写。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题。



##### Q25：如何理解闭包？

函数内部嵌套函数，内部函数会调用外部函数的变量或参数，内部函数被返回出去并执行，就会形成闭包，导致变量或参数会驻留在内存中。如果想实现一个变量常驻内存，但是又不会污染全局，即既具有全局变量的特点，又具有局部变量的特点，我们可以使用闭包。函数嵌套函数，并 return 里面的函数。



#####  Q26：hr 面试？

**站在别人的角度考虑，别总是说自己，也别把自己的利益放太高。**

**对 OD 模式了解过吗？**

了解过，是华为的一种新的招聘模式，跟其它公司签协议，但是同工同酬，表现优秀可以转为内部员工。

**上一个工作为什么离职？**

上一个公司对我特别好，我在公司的人缘也特别好，而且我想做什么，公司都给了我机会，我真的学到了很多很多，无论技术上的还是为人处世上的，所以很感谢上一家公司，希望以前的公司能越来越好。离职是因为以前公司的核心并不是开发，而且团队也比较小，想去一个专业的大团队，而且上一份工作的薪酬也比较低，因为当时招聘是以设计师的身份进去的，由于制度的原因也不会给我涨多少工资，所以就离开了。

**未来展望？**

希望能好好工作，与同事好好相处，先努力转正，再努力转为正式员工，在技术上，继续钻研，我感觉我的学习能力还是很强的，工作上用到的技术，我都会去钻研，努力写出好维护、好扩展、符合团队规范、稳定的代码。

**对于加班什么看法？**

我是可以接收的，上一个工作也经常加班，而且偶尔还通宵，我身体都是没有问题的。我觉得可能是因为我热爱工作吧，也热爱编程，我上一个工作一年多，我从来没有那种时间漫长的感觉，周一到周五一眨眼就过去了，还感觉工作没做完，晚上和周末，我都在钻研技术，工作上用到的以及自己感兴趣的其它领域的。

**为什么之前一年没上班？**

感觉做设计不知道怎么提升自己，在之前公司做设计的时候，做的大多数工作都是美工的活，对设计能力的提升也没有帮助，然后就辞职了，然后一年没有工作，关键是因为自己比较迷惘吧，不知道该做什么，想做开发，但是没有经验，水平也不是很强，想做设计吧，感觉跟科班出身的设计师比起来，没有竞争力。所以在这一年里，我好好沉淀沉淀了自己，在给别人做兼职设计的同时，也在网上报班学习编程和绘画。



