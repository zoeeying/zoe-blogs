# 2020 年前端面试题

##### Q1：是否使用过 Redux？Redux 解决了什么问题？是如何解决的？

Redux 是为了解决 React 组件间通讯和组件间状态共享的问题，主要包括三个部分：store、action、reducer。



##### Q2：是否使用过 React Hooks？主要用于解决什么问题？

React Hooks 解决了 HOC 和 Render Props 的嵌套问题，更加简洁；React Hooks 可以更方便地把 UI 和状态分离，做到更彻底的解耦；Hooks 中可以引用另外的 Hooks 形成新的 Hooks，组合变化万千；React Hooks 为函数组件而生，函数式编程风格看起来更清爽，更容易发现没有使用的状态和函数，代码量更少，解决了类组件中 this 指向容易错误的问题，解决了类组件中的逻辑分散在不同生命周期中，使得代码难以理解和维护的问题，解决了高阶组件容易使代码量剧增，代码维护成本很高的问题；React Hooks 使得我们复用状态逻辑，拆分组件更容易。



##### Q3：Vue 兄弟组件通讯有哪些方式？

aaa



##### Q4：常见的网络安全攻击有哪些，如何预防？

SSR



##### Q5：复杂动画场景中，为什么要提醒它们创建新图层？

aaa



##### Q6：在 HTTPS 协议打开的 H5 页面内，有某些 JS 或 CSS 资源会被 block，这是什么原因？图片资源会吗？

aaa



##### Q7：JS 异步优化历史、原理是什么？

aaa



##### Q8：Cookie 和 Session 的区别？

由于 HTTP 协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是 Session。典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。

思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。

Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。

所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。



##### Q9：进程间如何通讯？

管道通信；消息队列通信；信号量通信；信号通信；共享内存通信；套接字通信



##### Q10：自己在技术上擅长哪一方面？

aaa



##### Q11：怎么理解 MVVM？

Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表视图，在 Vue.js 中代表 UI 组件，负责将数据模型转化成 UI 展示出来；View 和 Model 之间没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，ViewModel 负责将 View 的变化同步到 Model 中，将 Model 数据的变化反应到 View 上，View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。



##### Q12：Vue 如何实现数据双向绑定？如何实现响应式数据？

Vue 数据双向绑定是通过**数据劫持**结合**发布者-订阅者模式**的方式来实现的。

通过 `Object.defineProperty()` 来劫持各个属性的 setter/getter，在 data 变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 `Object.defineProperty()` 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

Vue 的数据双向绑定将 MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 的数据变化，并在数据变化的时候发布通知，通过 Compile 来解析编译模板指令（`{{}}`），达到初始化视图的目的，并且还需要绑定更新函数，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，接收 Observer 发来的通知并执行 Compile 中相应的更新函数，达到数据变化 => 视图更新；视图交互变化（比如 input）=> 数据 model 变更的双向绑定效果。

```html
<body>
    <div id="app">
    <input type="text" id="txt">
    <p id="show"></p>
</div>
</body>
<script type="text/javascript">
    var obj = {}
    Object.defineProperty(obj, 'txt', {
        get: function () {
            return obj
        },
        set: function (newValue) {
            document.getElementById('txt').value = newValue
            document.getElementById('show').innerHTML = newValue
        }
    })
    document.addEventListener('keyup', function (e) {
        obj.txt = e.target.value
    })
</script>
```



##### Q13：为什么 Vue 组件中的 data 是一个函数？

每个 .vue 文件都是一个组件（组件是一个可复用的 Vue 实例），这就意味着如果 data 是一个普通的对象，那么所有复用这个实例的组件将共享引用同一个数据对象，这会造成数据污染，如果将 data 定义成一个函数，在实例化组件的时候，每个实例对象的 data 都是经过一次函数执行得到的全新的副本数据对象。

当一个**组件**被定义，`data` 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 `data` 仍然是一个纯粹的对象，则所有的实例将**共享引用**同一个数据对象！通过提供 `data` 函数，每次创建一个新实例后，我们能够调用 `data` 函数，从而返回初始数据的一个全新副本数据对象。



##### Q14：为什么使用 Flutter？跟 RN 和 Weex 比起来有什么优势？

Flutter 是一个跨平台 UI 开发框架，和以前的跨平台框架不同的是，它的**性能更好**，更接近原生并且跨平台体验更优秀，因为**它的跨平台实现机制更像是游戏引擎**。

Flutter 相较于 Weex 和 RN，性能强大、动画流畅；可以获得非常稳定的 UI 表达效果；避免了 RN 通过桥接器与Javascript 通讯导致效率低下的问题，所以在性能方面比 RN 更高一筹。



##### Q15：如何基于 Axios 封装请求？如果基于 Dio 封装请求？

aaa



##### Q16：HTTP 协议和 HTTPS 协议？

超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于 TCP/IP 协议传输数据，互联网上应用最为广泛的一种网络协议，所有的 WWW 文件都必须遵守这个标准。设计 HTTP 的初衷是为了提供一种发布和接收 HTML 页面的方法。HTTP 是一个基于 TCP/IP 通信协议来传递数据的协议，传输的数据类型为 HTML 文件、图片文件、查询结果等。

HTTPS 基于 HTTP 协议，通过 SSL 或 TLS 提供加密处理数据、验证对方身份以及数据完整性保护，一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。



##### Q17：token 过期怎么处理？

aaa



##### Q18：computed 和 watch 的区别和使用场景？

计算属性将被混入到 Vue 实例中。



##### Q19：hash 和 history？

hash 值变化不会导致浏览器向服务器发出请求；hash 虽然出现 url 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面；对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。



##### Q20：Vue 与 React 的区别？

都基于组件化的思想，组件之间可以嵌套；都基于 Virtual DOM 模型；都有官方提供的脚手架工具用来快速搭建应用。

React 使用 JSX，基于函数式编程的思想，使得开发人员可以充分利用 JavaScript 的编程能力；单向数据流，推崇结合 immutable 来实现数据不可变；手动性能优化；

Vue 使用 HTML 模板创建视图，且是国人开发的，文档是中文的，对于初次使用框架的人比较友好；双向数据绑定；对于将框架集成到现有项目中比较友好；响应式思想，监听属性变化，更新虚拟 DOM，更新视图；自动性能优化。



##### Q21：了解 keep-alive 吗？

**keep-alive** 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染，

在切换组件的时候，我们可能需要保存一些组件的状态，防止重复渲染，就可以使用 keep-alive 包裹需要保存状态的组件。 



##### Q22：Vue 中 key 的作用？React 中 key 的作用？

React 中 key 用来唯一标识同父同层级的兄弟元素，React 采用的 diff 算法是对新旧虚拟 DOM 树同层级的元素挨个进行比较，当 React 做 diff 时，只要子元素有 key 属性，便会去原虚拟 DOM 树中相应位置寻找是否有同 key 元素，比较它们是否完全相同，若相同则复用该元素，否则就进行更新。

当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用**就地更新**的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。key 的特殊属性主要用于 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。使用 key，可以更快速更准确地对比新旧虚拟 DOM，提高性能。



##### Q23：$route 和 $router 的区别？

$route 是**路由信息对象**，包括 path、params、hash、query、fullPath、matched、name 等路由信息参数；

$router 是**路由实例对象**，包括了路由的跳转方法、钩子函数等。



##### Q24：ES6 Proxy？

Proxy 可以理解成在目标对象前架设一个**拦截层**，外界对该对象的访问都必须先通过这层拦截，因此提供了一种机制可以对外界的访问进行过滤和改写。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为是 ES6 中的。



##### Q25：如何理解闭包？

函数内部嵌套函数，内部函数会调用外部函数的变量或参数，内部函数被返回出去并执行，就会形成闭包，导致变量或参数会驻留在内存中。如果想实现一个变量常驻内存，但是又不会污染全局，即既具有全局变量的特点，又具有局部变量的特点，我们可以使用闭包。函数嵌套函数，并 return 里面的函数。



#####  Q26：hr 面试？

**站在别人的角度考虑，别总是说自己，也别把自己的利益放太高。**

**对 OD 模式了解过吗？**

了解过，是华为的一种新的招聘模式，跟其它公司签协议，但是同工同酬，表现优秀可以转为内部员工。

**上一个工作为什么离职？**

上一个公司对我特别好，我在公司的人缘也特别好，而且我想做什么，公司都给了我机会，我真的学到了很多很多，无论技术上的还是为人处世上的，所以很感谢上一家公司，希望以前的公司能越来越好。离职是因为以前公司的核心并不是开发，而且团队也比较小，想去一个专业的大团队，而且上一份工作的薪酬也比较低，因为当时招聘是以设计师的身份进去的，由于制度的原因也不会给我涨多少工资，所以就离开了。

**未来展望？**

希望能好好工作，与同事好好相处，先努力转正，再努力转为正式员工，在技术上，继续钻研，我感觉我的学习能力还是很强的，工作上用到的技术，我都会去钻研，努力写出好维护、好扩展、符合团队规范、稳定的代码。

**对于加班什么看法？**

我是可以接收的，上一个工作也经常加班，而且偶尔还通宵，我身体都是没有问题的。我觉得可能是因为我热爱工作吧，也热爱编程，我上一个工作一年多，我从来没有那种时间漫长的感觉，周一到周五一眨眼就过去了，还感觉工作没做完，晚上和周末，我都在钻研技术，工作上用到的以及自己感兴趣的其它领域的。

**为什么之前一年没上班？**

感觉做设计不知道怎么提升自己，在之前公司做设计的时候，做的大多数工作都是美工的活，对设计能力的提升也没有帮助，然后就辞职了，然后一年没有工作，关键是因为自己比较迷惘吧，不知道该做什么，想做开发，但是没有经验，水平也不是很强，想做设计吧，感觉跟科班出身的设计师比起来，没有竞争力。所以在这一年里，我好好沉淀沉淀了自己，在给别人做兼职设计的同时，也在网上报班学习编程和绘画。



##### Q27：axios 和 fetch 的区别？

fetch 是浏览器提供的一个方法，是用于进行异步请求资源的，可以说跟 xhr 定位是一致的，但是 fetch 通过 promise 封装，在 ES7 的 async 的加持下能很好的开展业务。但是不是所有浏览器都支持 fetch，想实现 fetch，只能通过 xhr 来封装。

axios 是一种对 ajax 的封装，fetch 是一种浏览器原生实现的请求方式，跟 ajax 对等，它是一个异步请求资源的库，可以跑在浏览器端或者 node 端，浏览器端底层是通过 xhr 来实现的（当然也可以通过 fetch），node 端是用http 模块来实现的。

**补充：** ajax 是通过 xhr（XMLHttpRequest ）实现的，是浏览器宿主上的一个类。



##### Q28：有没有关注 Vue 3.0 beta？

主要体现在性能、Tree-shaking support 、Composition API 、Fragment 、TypeScript 支持度以及自定义 Render 上。



##### Q29：为什么 Vue 采用异步渲染？

Vue 是组件级更新的，如果不采用异步渲染，那么每次更新数据都会对当前组件进行重新渲染，所以为了**性能考虑**，Vue 会在本轮数据更新后，再去异步渲染更新视图。



##### Q30：异步组件？

异步组件就是定义的时候什么都不做，只在组件需要渲染（组件第一次显示）的时候进行加载渲染并缓存，缓存是以备下次访问。

Vue 实现按需加载，官方推荐使用结合 Webpack 的代码分割功能进行，定义为异步加载的组件，在打包的时候，会打包成单独的 js 文件存储在 static/js 文件夹里面，在调用时使用 ajax 请求回来插入到 html 中。



##### Q31：你擅长什么？



##### Q32：首屏优化？



##### Q33：Webpack 的实现原理？



##### Q34：CommonJS 和 ES6 Module 的区别



##### Q35：什么情况下会阻塞 DOM 渲染？





##### Q36：宏任务和微任务



##### Q37：CSS 层叠上下文以及 z-index





##### Q38：CSS3 动画



##### Q39：ES6、ES7、ES8的特性



##### Q40：DOM 事件流、事件委托、addEventListener、事件对象

DOM 事件流：事件捕获阶段 => 目标元素阶段 => 事件冒泡阶段。

事件捕获最先发生，为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。

事件委托利用事件冒泡，可以只使用一个事件处理程序来管理一种类型的事件。比如在父元素上绑定一个事件监听函数，通过 event 对象来区分不同的触发元素，从而进行相应逻辑的处理。

事件对象：在 DOM 中发生事件时，所有相关信息都会被收集并存储在事件对象中。

事件对象的属性：currentTarget 表示当前事件处理程序所在的元素；target 表示事件绑定的实际目标；在事件处理函数内部，this 始终等于 currentTarget。如果事件处理程序直接添加在了意图的目标，那么 currentTarget、target、this 三者的值是相等的。

**addEventListener**：第一个参数是事件名，不需要加上 on；第二个参数是事件处理函数；第三个参数表示事件处理函数是否在捕获阶段执行，默认值是 false。

##### Q42：Webpack 的 loader 和 plugin 的区别



##### Q43：HTTP 状态码？206？



##### Q44：React 高阶组件的作用？



##### Q45：Service Worker？



##### Q46：文件上传的二进制具体是怎么处理的？



##### Q47：Chrome 插件如何屏蔽广告？



##### Q48：`Object.is()`



##### Q49：Event Loop



##### Q50：绝对定位、固定定位和 z-index



##### Q51：你觉得你做的最有成就感的一件事情？



##### Q52：解决问题的方法？



##### Q53：Flex 如何实现上下两行，上行高度自适应，下行高度 200px？



##### Q54：React 中的 setState 为什么需要异步操作？



##### Q55：数组和对象如何检测？判断一个对象是不是数组？	

1、`Array.isArray()` 确定一个值是否是数组，不管它是在哪个全局执行上下文中创建的。

```javascript
Array.isArray([]) // true
```

2、`toString.call()` 是 `Object.prototype.toString.call()` 的简写。

```javascript
// 通过call指定数组[]为Object.prototype对象中的toString方法的上下文
toString.call([]) // "[object Array]"
```

3、instanceof 检查实例的原型链中是否包含指定构造函数的原型

```javascript
[] instanceof Array // true
[] instanceof Object // true
null instanceof Object // false
```

##### Q56：数组去重？

```javascript
let arr = [1, 2, 3, 1, 4]
arr = [...new Set(arr)]
```

```javascript
const colors = ['yellow', 'green', 'blue', 'red', 'green', 'blue']
const distinctColors = colors.reduce(
  (distinct, color) =>
    distinct.includes(color) ? distinct : [...distinct, color],
  []
)
console.log(distinctColors)
```



















