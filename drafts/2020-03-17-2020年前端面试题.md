# 2021 年前端面试题

##### Q1：是否使用过 Redux？Redux 解决了什么问题？是如何解决的？

Redux 是为了解决 React 组件间通讯和组件间状态共享的问题，主要包括三个部分：store、action、reducer。



##### Q2：是否使用过 React Hooks？主要用于解决什么问题？

React Hooks 解决了 HOC 和 Render Props 的嵌套问题，更加简洁；React Hooks 可以更方便地把 UI 和状态分离，做到更彻底的解耦；Hooks 中可以引用另外的 Hooks 形成新的 Hooks，组合变化万千；React Hooks 为函数组件而生，函数式编程风格看起来更清爽，更容易发现没有使用的状态和函数，代码量更少，解决了类组件中 this 指向容易错误的问题，解决了类组件中的逻辑分散在不同生命周期中，使得代码难以理解和维护的问题，解决了高阶组件容易使代码量剧增，代码维护成本很高的问题；React Hooks 使得我们复用状态逻辑，拆分组件更容易。



##### Q3：Vue 兄弟组件通讯有哪些方式？

aaa



##### Q4：常见的网络安全攻击有哪些，如何预防？

SSR



##### Q5：复杂动画场景中，为什么要提醒它们创建新图层？

aaa



##### Q6：在 HTTPS 协议打开的 H5 页面内，有某些 JS 或 CSS 资源会被 block，这是什么原因？图片资源会吗？

aaa



##### Q7：JS 异步优化历史、原理是什么？

aaa



##### Q8：Cookie 和 Session 的区别？

由于 HTTP 协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识别具体的用户，这个机制就是 Session。典型的场景比如购物车，当你点击下单按钮时，由于 HTTP 协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建特定的 Session，用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个 Session 是保存在服务端的，有一个唯一标识。在服务端保存 Session 的方法很多，内存、数据库、文件都有。集群的时候也要考虑 Session 的转移，在大型的网站，一般会有专门的 Session 服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如 Memcached 之类的来放 Session。

思考一下服务端如何识别特定的客户？这个时候 Cookie 就登场了。每次 HTTP 请求的时候，客户端都会发送相应的 Cookie 信息到服务端。实际上大多数的应用都是用 Cookie 来实现 Session 跟踪的，第一次创建 Session 的时候，服务端会在 HTTP 协议中告诉客户端，需要在 Cookie 里面记录一个 Session ID，以后每次请求把这个会话 ID 发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做 **URL 重写**的技术来进行会话跟踪，即每次 HTTP 交互，URL 后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。

Cookie 其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到 Cookie 里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是 Cookie 名称的由来，给用户的一点甜头。

所以，总结一下：Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。



##### Q9：进程间如何通讯？

管道通信；消息队列通信；信号量通信；信号通信；共享内存通信；套接字通信



##### Q10：自己在技术上擅长哪一方面？

aaa



##### Q11：怎么理解 MVVM？

Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表视图，在 Vue.js 中代表 UI 组件，负责将数据模型转化成 UI 展示出来；View 和 Model 之间没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，ViewModel 负责将 View 的变化同步到 Model 中，将 Model 数据的变化反应到 View 上，View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。



##### Q12：Vue 如何实现数据双向绑定？如何实现响应式数据？

Vue 数据双向绑定是通过**数据劫持**结合**发布者-订阅者模式**的方式来实现的。

通过 `Object.defineProperty()` 来劫持各个属性的 setter/getter，在 data 变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 `Object.defineProperty()` 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

Vue 的数据双向绑定将 MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 的数据变化，并在数据变化的时候发布通知，通过 Compile 来解析编译模板指令（`{{}}`），达到初始化视图的目的，并且还需要绑定更新函数，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，接收 Observer 发来的通知并执行 Compile 中相应的更新函数，达到数据变化 => 视图更新；视图交互变化（比如 input）=> 数据 model 变更的双向绑定效果。

```html
<body>
    <div id="app">
    <input type="text" id="txt">
    <p id="show"></p>
</div>
</body>
<script type="text/javascript">
    var obj = {}
    Object.defineProperty(obj, 'txt', {
        get: function () {
            return obj
        },
        set: function (newValue) {
            document.getElementById('txt').value = newValue
            document.getElementById('show').innerHTML = newValue
        }
    })
    document.addEventListener('keyup', function (e) {
        obj.txt = e.target.value
    })
</script>
```



##### Q13：为什么 Vue 组件中的 data 是一个函数？

每个 .vue 文件都是一个组件（组件是一个可复用的 Vue 实例），这就意味着如果 data 是一个普通的对象，那么所有复用这个实例的组件将共享引用同一个数据对象，这会造成数据污染，如果将 data 定义成一个函数，在实例化组件的时候，每个实例对象的 data 都是经过一次函数执行得到的全新的副本数据对象。

当一个**组件**被定义，`data` 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 `data` 仍然是一个纯粹的对象，则所有的实例将**共享引用**同一个数据对象！通过提供 `data` 函数，每次创建一个新实例后，我们能够调用 `data` 函数，从而返回初始数据的一个全新副本数据对象。



##### Q14：为什么使用 Flutter？跟 RN 和 Weex 比起来有什么优势？

Flutter 是一个跨平台 UI 开发框架，和以前的跨平台框架不同的是，它的**性能更好**，更接近原生并且跨平台体验更优秀，因为**它的跨平台实现机制更像是游戏引擎**。

Flutter 相较于 Weex 和 RN，性能强大、动画流畅；可以获得非常稳定的 UI 表达效果；避免了 RN 通过桥接器与Javascript 通讯导致效率低下的问题，所以在性能方面比 RN 更高一筹。



##### Q15：如何基于 Axios 封装请求？如何基于 Dio 封装请求？如何基于 fetch 封装请求？

aaa



##### Q16：HTTP 协议和 HTTPS 协议？

超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于 TCP/IP 协议传输数据，互联网上应用最为广泛的一种网络协议，所有的 WWW 文件都必须遵守这个标准。设计 HTTP 的初衷是为了提供一种发布和接收 HTML 页面的方法。HTTP 是一个基于 TCP/IP 通信协议来传递数据的协议，传输的数据类型为 HTML 文件、图片文件、查询结果等。

HTTPS 基于 HTTP 协议，通过 SSL 或 TLS 提供加密处理数据、验证对方身份以及数据完整性保护，一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。



##### Q17：token 过期怎么处理？

aaa



##### Q18：computed 和 watch 的区别和使用场景？

计算属性将被混入到 Vue 实例中。



##### Q19：hash 和 history？

hash 值变化不会导致浏览器向服务器发出请求；hash 虽然出现 url 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面；对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。



##### Q20：Vue 与 React 的区别？

都基于组件化的思想，组件之间可以嵌套；都基于 Virtual DOM 模型；都有官方提供的脚手架工具用来快速搭建应用。

React 使用 JSX，基于函数式编程的思想，使得开发人员可以充分利用 JavaScript 的编程能力；单向数据流，推崇结合 immutable 来实现数据不可变；手动性能优化。

Vue 使用 HTML 模板创建视图，且是国人开发的，文档是中文的，对于初次使用框架的人比较友好；双向数据绑定；对于将框架集成到现有项目中比较友好；响应式思想，监听属性变化，更新虚拟 DOM，更新视图；自动性能优化。



##### Q21：了解 keep-alive 吗？

**keep-alive** 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染，

在切换组件的时候，我们可能需要保存一些组件的状态，防止重复渲染，就可以使用 keep-alive 包裹需要保存状态的组件。 



##### Q22：Vue 中 key 的作用？React 中 key 的作用？

React 中 key 用来唯一标识同父同层级的兄弟元素，React 采用的 diff 算法是对新旧虚拟 DOM 树同层级的元素挨个进行比较，当 React 做 diff 时，只要子元素有 key 属性，便会去原虚拟 DOM 树中相应位置寻找是否有同 key 元素，比较它们是否完全相同，若相同则复用该元素，否则就进行更新。

当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用**就地更新**的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。key 的特殊属性主要用于 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。使用 key，可以更快速更准确地对比新旧虚拟 DOM，提高性能。



##### Q23：$route 和 $router 的区别？

$route 是**路由信息对象**，包括 path、params、hash、query、fullPath、matched、name 等路由信息参数。

$router 是**路由实例对象**，包括了路由的跳转方法、钩子函数等。



##### Q24：ES6 Proxy？

Proxy 可以理解成在目标对象前架设一个**拦截层**，外界对该对象的访问都必须先通过这层拦截，因此提供了一种机制可以对外界的访问进行过滤和改写。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为是 ES6 中的。



##### Q25：如何理解闭包？

函数内部嵌套函数，内部函数会调用外部函数的变量或参数，内部函数被返回出去并执行，就会形成闭包，导致变量或参数会驻留在内存中。如果想实现一个变量常驻内存，但是又不会污染全局，即既具有全局变量的特点，又具有局部变量的特点，我们可以使用闭包。函数嵌套函数，并 return 里面的函数。



#####  Q26：hr 面试？

**站在别人的角度考虑，别总是说自己，也别把自己的利益放太高。**

**对 OD 模式了解过吗？**

了解过，是华为的一种新的招聘模式，跟其它公司签协议，但是同工同酬，表现优秀可以转为内部员工。

**上一个工作为什么离职？**

上一个公司对我特别好，我在公司的人缘也特别好，而且我想做什么，公司都给了我机会，我真的学到了很多很多，无论技术上的还是为人处世上的，所以很感谢上一家公司，希望以前的公司能越来越好。离职是因为以前公司的核心并不是开发，而且团队也比较小，想去一个专业的大团队，而且上一份工作的薪酬也比较低，因为当时招聘是以设计师的身份进去的，由于制度的原因也不会给我涨多少工资，所以就离开了。

**未来展望？**

希望能好好工作，与同事好好相处，先努力转正，再努力转为正式员工，在技术上，继续钻研，我感觉我的学习能力还是很强的，工作上用到的技术，我都会去钻研，努力写出好维护、好扩展、符合团队规范、稳定的代码。

**对于加班什么看法？**

我是可以接收的，上一个工作也经常加班，而且偶尔还通宵，我身体都是没有问题的。我觉得可能是因为我热爱工作吧，也热爱编程，我上一个工作一年多，我从来没有那种时间漫长的感觉，周一到周五一眨眼就过去了，还感觉工作没做完，晚上和周末，我都在钻研技术，工作上用到的以及自己感兴趣的其它领域的。

**为什么之前一年没上班？**

感觉做设计不知道怎么提升自己，在之前公司做设计的时候，做的大多数工作都是美工的活，对设计能力的提升也没有帮助，然后就辞职了，然后一年没有工作，关键是因为自己比较迷惘吧，不知道该做什么，想做开发，但是没有经验，水平也不是很强，想做设计吧，感觉跟科班出身的设计师比起来，没有竞争力。所以在这一年里，我好好沉淀沉淀了自己，在给别人做兼职设计的同时，也在网上报班学习编程和绘画。



##### Q27：axios 和 fetch 的区别？

fetch 是浏览器提供的一个方法，是用于进行异步请求资源的，可以说跟 xhr 定位是一致的，但是 fetch 通过 promise 封装，在 ES7 的 async 的加持下能很好的开展业务。但是不是所有浏览器都支持 fetch，想实现 fetch，只能通过 xhr 来封装。

axios 是一种对 ajax 的封装，fetch 是一种浏览器原生实现的请求方式，跟 ajax 对等，它是一个异步请求资源的库，可以跑在浏览器端或者 node 端，浏览器端底层是通过 xhr 来实现的（当然也可以通过 fetch），node 端是用 http 模块来实现的。

**补充：** ajax 是通过 xhr（XMLHttpRequest ）实现的，是浏览器宿主上的一个类。



##### Q28：有没有关注 Vue 3.0 beta？

主要体现在性能、Tree-shaking support 、Composition API 、Fragment 、TypeScript 支持度以及自定义 Render 上。



##### Q29：为什么 Vue 采用异步渲染？

Vue 是组件级更新的，如果不采用异步渲染，那么每次更新数据都会对当前组件进行重新渲染，所以为了**性能考虑**，Vue 会在本轮数据更新后，再去异步渲染更新视图。



##### Q30：异步组件？

异步组件就是定义的时候什么都不做，只在组件需要渲染（组件第一次显示）的时候进行加载渲染并缓存，缓存是以备下次访问。

Vue 实现按需加载，官方推荐使用结合 Webpack 的代码分割功能进行，定义为异步加载的组件，在打包的时候，会打包成单独的 js 文件存储在 static/js 文件夹里面，在调用时使用 ajax 请求回来插入到 html 中。



##### Q31：你擅长什么？



##### Q32：首屏优化？



##### Q33：Webpack 的实现原理？构建流程？

省略，我的博客有详细的 Webpack 学习笔记。



##### Q42：Webpack 的 loader 和 plugin 的区别？

Webpack 默认不能打包非 JS 模块，需要使用 loader 来打包，是一种文件转换器，比如把 ES6 转换为 ES5，scss 转换为 css 等。

plugin 用于扩展 Webpack 的功能，在 Webpack 构建生命周期的节点帮助做一些事情，比如 html-webpack-plugin 插件会在打包之后，根据配置的 HTML 模板文件在 dist 目录下生成一个 HTML 文件，并把打包生成的 JS 文件自动引入到这个 HTML 文件中。



##### Q34：CommonJS 模块和 ES6 模块的区别？

CommonJS 模块是**运行时加载**，因为 CommonJS 加载的是一个**对象**，即 module.exports 属性，该对象只有在脚本运行结束时才会生成。

ES6 模块是**编译时输出接口**，因为 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

CommonJS 模块输出的是一个**值的复制**，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值，存在值的缓存。

ES6 模块输出的是**值的引用**，是因为 JS 引擎对脚本静态分析的时候，遇到模块加载命令 import 就会生成一个**只读引用**，等到脚本真正执行时，再根据这个只读引用到被加载的模块中取值，所以 ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。export 通过接口输出的是同一个值，不同的脚本加载这个接口得到的都是同样的实例。

`export {}` 并不是输出空对象，而是**不输出任何接口**的 ES6 标准写法。

ES6 模块中顶层的 this 指向 undefined，CommonJS 模块顶层的 this 指向当前模块。



##### Q35：什么情况下会阻塞 DOM 渲染？

1、遇到 script 标签，会去加载并执行脚本，完成之后才会继续渲染。

2、遇到 alert 也会阻塞 DOM 渲染。

3、遇到 link 标签，会去加载并解析 CSS，不会阻塞 HTML 解析，但是加载 CSS 的时候会阻塞 DOM 树渲染，而且 CSS 加载会阻塞后面 JS 语句的执行，所以必须想办法提高 CSS 的加载速度。



##### Q36：宏任务和微任务



##### Q37：CSS 层叠上下文以及 z-index



##### Q38：CSS3 动画



##### Q39：ES6、ES7、ES8的特性



##### Q40：DOM 事件流、事件委托、addEventListener、事件对象

DOM 事件流：事件捕获阶段 => 目标元素阶段 => 事件冒泡阶段。

事件捕获最先发生，为提前拦截事件提供了可能。然后，实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。

事件委托利用事件冒泡，可以只使用一个事件处理程序来管理一种类型的事件。比如在父元素上绑定一个事件监听函数，通过 event 对象来区分不同的触发元素，从而进行相应逻辑的处理。

事件对象：在 DOM 中发生事件时，所有相关信息都会被收集并存储在事件对象中。

事件对象的属性：currentTarget 表示当前事件处理程序所在的元素；target 表示事件绑定的实际目标；在事件处理函数内部，this 始终等于 currentTarget。如果事件处理程序直接添加在了意图的目标，那么 currentTarget、target、this 三者的值是相等的。

**addEventListener：** 第一个参数是事件名，不需要加上 on；第二个参数是事件处理函数；第三个参数表示事件处理函数是否在捕获阶段执行，默认值是 false。



##### Q43：HTTP 状态码？206？



##### Q44：React 高阶组件的作用？



##### Q45：Service Worker？



##### Q49：Event Loop



##### Q50：绝对定位、固定定位和 z-index



##### Q51：你觉得你做的最有成就感的一件事情？



##### Q52：解决问题的方法？



##### Q53：Flex 如何实现上下两行，上行高度自适应，下行高度 200px？



##### Q54：React 中的 setState 为什么需要异步操作？



##### Q55：数组和对象如何检测？判断一个对象是不是数组？	

1、`Array.isArray()` 确定一个值是否是数组，不管它是在哪个全局执行上下文中创建的。

```javascript
Array.isArray([]) // true
```

2、`toString.call()` 是 `Object.prototype.toString.call()` 的简写。

```javascript
// 通过call指定数组[]为Object.prototype对象中的toString方法的上下文
toString.call([]) // "[object Array]"
```

3、instanceof 检查实例的原型链中是否包含指定构造函数的原型

```javascript
[] instanceof Array // true
[] instanceof Object // true
null instanceof Object // false
```

##### Q56：数组去重？

```javascript
let arr = [1, 2, 3, 1, 4]
arr = [...new Set(arr)]
```

```javascript
const colors = ['yellow', 'green', 'blue', 'red', 'green', 'blue']
const distinctColors = colors.reduce(
  (distinct, color) =>
    distinct.includes(color) ? distinct : [...distinct, color],
  []
)
console.log(distinctColors)
```

##### Q57：Immutable.js

Immutable Data 一旦创建就不能被修改。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。Immutable 本身就是函数式编程中的概念。

Immutable.js 是 Facebook 工程师开发的不可变数据集合。

##### Q58：BOM 中常用的对象？

window、document、location、screen、history、navigator

##### Q59：内置对象、宿主对象？

**内置对象**是指任何由 ECMAScript 实现提供，与宿主环境无关，并在 ECMAScript 程序开始执行时就存在的对象，这意味着开发者不用显式地实例化内置对象，因为它们已经实例化好了。Global 和 Math 是单例内置对象。Array、Object 也都是内置对象。

**宿主对象：** 由 ECMAScript 实现的宿主环境提供的对象，所有的 BOM 和 DOM 对象都是宿主对象。

##### Q60：window.location

window.location.search 返回查询参数部分，包括问号。

window.location.hash 返回锚点，比如对于 `http://www.baidu.com/getname?#age`，返回 `#age`，注意，改变路径中的锚点不会发起服务器请求。

window.location.reload 用来刷新当前页面。









